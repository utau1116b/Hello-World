;==================================================
;
;	汎用関数置き場＠便利関数編
;		演算や命令、組み込み関数の拡張にあたるもの
;
;		おおよそバリアントを問わず使えるものが多いです
;
;==================================================

;-------------------------------------------------
;確率判定関数@PERCENT
;式中で使用する関数です。引数％の確率判定を行います。通れば1を返します
;常用する関数ですが、なぜ本体にこれ無いんだろ…。
;-------------------------------------------------
@PERCENT(ARG)
#FUNCTION
RETURNF (ARG - RAND:100) > 0


;-------------------------------------------------
;数値型インプット関数@INPUTINT
;　引数0〜99：入力可能な数字
;数値の入力待ちをします。引数に含まれない数字を選んだら自動的に入力待ちをし直します
;有効な数字が入力されたらそれをRESULTへ返して戻ります
;選択肢を汎用処理するため、ループの構文を書く必要がなくなります
;引数が妙な値なのは、-1とかだと被るから。nullがあればいいのだけどねえ。
;-------------------------------------------------
@INPUTINT(ARG:0 = -147258369, ARG:1 = -147258369, ARG:2 = -147258369, ARG:3 = -147258369, ARG:4 = -147258369, ARG:5 = -147258369, ARG:6 = -147258369, ARG:7 = -147258369, ARG:8 = -147258369, ARG:9 = -147258369, ARG:10 = -147258369, ARG:11 = -147258369, ARG:12 = -147258369, ARG:13 = -147258369, ARG:14 = -147258369, ARG:15 = -147258369, ARG:16 = -147258369, ARG:17 = -147258369, ARG:18 = -147258369, ARG:19 = -147258369, ARG:20 = -147258369, ARG:21 = -147258369, ARG:22 = -147258369, ARG:23 = -147258369, ARG:24 = -147258369, ARG:25 = -147258369, ARG:26 = -147258369, ARG:27 = -147258369, ARG:28 = -147258369, ARG:29 = -147258369, ARG:30 = -147258369, ARG:31 = -147258369, ARG:32 = -147258369, ARG:33 = -147258369, ARG:34 = -147258369, ARG:35 = -147258369, ARG:36 = -147258369, ARG:37 = -147258369, ARG:38 = -147258369, ARG:39 = -147258369, ARG:40 = -147258369, ARG:41 = -147258369, ARG:42 = -147258369, ARG:43 = -147258369, ARG:44 = -147258369, ARG:45 = -147258369, ARG:46 = -147258369, ARG:47 = -147258369, ARG:48 = -147258369, ARG:49 = -147258369, ARG:50 = -147258369, ARG:51 = -147258369, ARG:52 = -147258369, ARG:53 = -147258369, ARG:54 = -147258369, ARG:55 = -147258369, ARG:56 = -147258369, ARG:57 = -147258369, ARG:58 = -147258369, ARG:59 = -147258369, ARG:60 = -147258369, ARG:61 = -147258369, ARG:62 = -147258369, ARG:63 = -147258369, ARG:64 = -147258369, ARG:65 = -147258369, ARG:66 = -147258369, ARG:67 = -147258369, ARG:68 = -147258369, ARG:69 = -147258369, ARG:70 = -147258369, ARG:71 = -147258369, ARG:72 = -147258369, ARG:73 = -147258369, ARG:74 = -147258369, ARG:75 = -147258369, ARG:76 = -147258369, ARG:77 = -147258369, ARG:78 = -147258369, ARG:79 = -147258369, ARG:80 = -147258369, ARG:81 = -147258369, ARG:82 = -147258369, ARG:83 = -147258369, ARG:84 = -147258369, ARG:85 = -147258369, ARG:86 = -147258369, ARG:87 = -147258369, ARG:88 = -147258369, ARG:89 = -147258369, ARG:90 = -147258369, ARG:91 = -147258369, ARG:92 = -147258369, ARG:93 = -147258369, ARG:94 = -147258369, ARG:95 = -147258369, ARG:96 = -147258369, ARG:97 = -147258369, ARG:98 = -147258369, ARG:99 = -147258369)
INPUT
SELECTCASE RESULT
	CASE ARG:0, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20, ARG:21, ARG:22, ARG:23, ARG:24, ARG:25, ARG:26, ARG:27, ARG:28, ARG:29, ARG:30, ARG:31, ARG:32, ARG:33, ARG:34, ARG:35, ARG:36, ARG:37, ARG:38, ARG:39, ARG:40, ARG:41, ARG:42, ARG:43, ARG:44, ARG:45, ARG:46, ARG:47, ARG:48, ARG:49, ARG:50, ARG:51, ARG:52, ARG:53, ARG:54, ARG:55, ARG:56, ARG:57, ARG:58, ARG:59, ARG:60, ARG:61, ARG:62, ARG:63, ARG:64, ARG:65, ARG:66, ARG:67, ARG:68, ARG:69, ARG:70, ARG:71, ARG:72, ARG:73, ARG:74, ARG:75, ARG:76, ARG:77, ARG:78, ARG:79, ARG:80, ARG:81, ARG:82, ARG:83, ARG:84, ARG:85, ARG:86, ARG:87, ARG:88, ARG:89, ARG:90, ARG:91, ARG:92, ARG:93, ARG:94, ARG:95, ARG:96, ARG:97, ARG:98, ARG:99
		RETURN RESULT
ENDSELECT
RESTART

;-------------------------------------------------
;数値型時間制限インプット関数@TINPUTINT
;	引数0：制限時間(ms)
;	引数1：時間切れ時の戻り値（デフォルトで-1）
;	引数2：=1だと残り時間を表示
;	引数3〜102：入力可能な数字
;引数3以降で与えられた番号を有効な選択肢として数値の入力を受け付けます
;引数に含まれない数字だとやり直し。RESULTに選んだ値を返します
;-------------------------------------------------
@TINPUTINT(ARG:0, ARG:1 = -1, ARG:2, ARG:3 = -147258369, ARG:4 = -147258369, ARG:5 = -147258369, ARG:6 = -147258369, ARG:7 = -147258369, ARG:8 = -147258369, ARG:9 = -147258369, ARG:10 = -147258369, ARG:11 = -147258369, ARG:12 = -147258369, ARG:13 = -147258369, ARG:14 = -147258369, ARG:15 = -147258369, ARG:16 = -147258369, ARG:17 = -147258369, ARG:18 = -147258369, ARG:19 = -147258369, ARG:20 = -147258369, ARG:21 = -147258369, ARG:22 = -147258369, ARG:23 = -147258369, ARG:24 = -147258369, ARG:25 = -147258369, ARG:26 = -147258369, ARG:27 = -147258369, ARG:28 = -147258369, ARG:29 = -147258369, ARG:30 = -147258369, ARG:31 = -147258369, ARG:32 = -147258369, ARG:33 = -147258369, ARG:34 = -147258369, ARG:35 = -147258369, ARG:36 = -147258369, ARG:37 = -147258369, ARG:38 = -147258369, ARG:39 = -147258369, ARG:40 = -147258369, ARG:41 = -147258369, ARG:42 = -147258369, ARG:43 = -147258369, ARG:44 = -147258369, ARG:45 = -147258369, ARG:46 = -147258369, ARG:47 = -147258369, ARG:48 = -147258369, ARG:49 = -147258369, ARG:50 = -147258369, ARG:51 = -147258369, ARG:52 = -147258369, ARG:53 = -147258369, ARG:54 = -147258369, ARG:55 = -147258369, ARG:56 = -147258369, ARG:57 = -147258369, ARG:58 = -147258369, ARG:59 = -147258369, ARG:60 = -147258369, ARG:61 = -147258369, ARG:62 = -147258369, ARG:63 = -147258369, ARG:64 = -147258369, ARG:65 = -147258369, ARG:66 = -147258369, ARG:67 = -147258369, ARG:68 = -147258369, ARG:69 = -147258369, ARG:70 = -147258369, ARG:71 = -147258369, ARG:72 = -147258369, ARG:73 = -147258369, ARG:74 = -147258369, ARG:75 = -147258369, ARG:76 = -147258369, ARG:77 = -147258369, ARG:78 = -147258369, ARG:79 = -147258369, ARG:80 = -147258369, ARG:81 = -147258369, ARG:82 = -147258369, ARG:83 = -147258369, ARG:84 = -147258369, ARG:85 = -147258369, ARG:86 = -147258369, ARG:87 = -147258369, ARG:88 = -147258369, ARG:89 = -147258369, ARG:90 = -147258369, ARG:91 = -147258369, ARG:92 = -147258369, ARG:93 = -147258369, ARG:94 = -147258369, ARG:95 = -147258369, ARG:96 = -147258369, ARG:97 = -147258369, ARG:98 = -147258369, ARG:99 = -147258369, ARG:100 = -147258369, ARG:101 = -147258369, ARG:102 = -147258369)
TINPUT ARG, ARG:1, ARG:2
SELECTCASE RESULT
	CASE ARG:1, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20, ARG:21, ARG:22, ARG:23, ARG:24, ARG:25, ARG:26, ARG:27, ARG:28, ARG:29, ARG:30, ARG:31, ARG:32, ARG:33, ARG:34, ARG:35, ARG:36, ARG:37, ARG:38, ARG:39, ARG:40, ARG:41, ARG:42, ARG:43, ARG:44, ARG:45, ARG:46, ARG:47, ARG:48, ARG:49, ARG:50, ARG:51, ARG:52, ARG:53, ARG:54, ARG:55, ARG:56, ARG:57, ARG:58, ARG:59, ARG:60, ARG:61, ARG:62, ARG:63, ARG:64, ARG:65, ARG:66, ARG:67, ARG:68, ARG:69, ARG:70, ARG:71, ARG:72, ARG:73, ARG:74, ARG:75, ARG:76, ARG:77, ARG:78, ARG:79, ARG:80, ARG:81, ARG:82, ARG:83, ARG:84, ARG:85, ARG:86, ARG:87, ARG:88, ARG:89, ARG:90, ARG:91, ARG:92, ARG:93, ARG:94, ARG:95, ARG:96, ARG:97, ARG:98, ARG:99, ARG:100, ARG:101, ARG:102
		RETURN RESULT
ENDSELECT
RESTART

;-------------------------------------------------
;数量入力用関数　@INPUT_MANY
;ARGで最小値、ARG:1で最大値を指定
;電卓風のコンソールから数値を入力させる
;
;ARG・ARG:1　最低値あるいは最大値　順序は逆でもよい
;ARGS　オプション。とりあえずいまはログを残すのみ
;ARGS:1　例外の数値設定。範囲外でも通る数値を設定する
;		 記述方法は0/20/30/-1といったように、文字列で"/"を区切り文字とする
;-------------------------------------------------
@INPUT_MANY(ARG, ARG:1, ARGS = "ログを残す", ARGS:1)
#LOCALSIZE 3
#LOCALSSIZE 20
#DIM LINE, 1
;最初は0
LOCAL = 0
LOCAL:1 = 1
VARSET LOCALS
SPLIT ARGS:1, "/", LOCALS
LINE = LINECOUNT
$START
REDRAW 0
CLEARLINE LINECOUNT - LINE
PRINTFORML 【{LOCAL}】　《【{ARG}】 - 【{ARG:1}】》
PRINTBUTTON "[7]", "７"
PRINT 　
PRINTBUTTON "[8]", "８"
PRINT 　
PRINTBUTTON "[9]", "９"
PRINT 　
PRINTBUTTON "[ AC]", "AC"
PRINTL 

PRINTBUTTON "[4]", "４"
PRINT 　
PRINTBUTTON "[5]", "５"
PRINT 　
PRINTBUTTON "[6]", "６"
PRINT 　
PRINTBUTTON "[Max]", "MAX"
PRINTL 

PRINTBUTTON "[1]", "１"
PRINT 　
PRINTBUTTON "[2]", "２"
PRINT 　
PRINTBUTTON "[3]", "３"
PRINT 　
PRINTBUTTON "[Min]", "MIN"
PRINTL 

PRINTBUTTON "[0]", "０"
PRINT 　
IF LOCAL:1 == -1
	PRINTBUTTON "[+]", "+"
ELSE
	PRINTBUTTON "[-]", "-"
ENDIF
PRINT 　
PRINTBUTTON "[ENTER]", "ENTER"
PRINTL 
PRINTFORML ※キーボードから、直接数値を入力することもできます
INPUTS
SELECTCASE RESULTS
	CASE "AC"
		RESTART
	CASE "+"
		LOCAL *= -1
		LOCAL:1 = 1
	CASE "-"
		LOCAL *= -1
		LOCAL:1 = -1
	CASE "MIN"
		LOCAL = ARG
	CASE "MAX"
		LOCAL = ARG:1
	CASE "０", "１", "２", "３", "４", "５", "６", "７", "８", "９"
		IF LOCAL == 0
			LOCAL = ABS(LOCAL) + TOINT(TOHALF(RESULTS)) * LOCAL:1
		ELSE
			;桁数を取る
			LOCAL:2 = 1
			WHILE LOCAL >= POWER(10, LOCAL:2)
				LOCAL:2++
				IF LOCAL:2 > 18
					PRINTFORMW 桁数が多すぎます！
					GOTO START
				ENDIF
			WEND
			LOCAL = LOCAL * 10 + TOINT(TOHALF(RESULTS))
		ENDIF
	CASEELSE
		IF RESULTS != "ENTER"
 			FOR LOCAL:2, 0, STRLENS(RESULTS)
 				SIF GROUPMATCH(SUBSTRING(RESULTS, LOCAL:2, 1), "0", "1", "2", "3", "4", "5", "6", "7", "8", "9")
 					CONTINUE
				PRINTFORMW 入力が異常です。入力しなおしてください
				RESTART
 			NEXT
			LOCAL = TOINT(RESULTS)
		ENDIF
		IF RANGE(LOCAL, ARG, ARG:1) || MATCH(LOCALS, TOSTR(LOCAL))
			SIF !STRCOUNT(ARGS, "ログを残す")
				CLEARLINE LINE - LINECOUNT
			REDRAW 1
			RETURN LOCAL
		ELSE
			PRINTFORMW 数値が範囲外です。入力しなおしてください
			RESTART
		ENDIF
ENDSELECT
GOTO START

;-------------------------------------------------
;未読判定関数@FIRSTTIME
;式中で使用する関数です。理論上無限にイベントを登録できます。
;特に使用法に指定のない、イベントの初回判定用関数です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:2で管理します
;-------------------------------------------------
@FIRSTTIME(ARG, ARG:1 = -2, ARG:2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF FIRSTPROCESS(ARG:1, @"TIME%TOSTR(ARG)%", ARG:2, 2)

;汎用初回判定処理
;引数はキャラ番号、判定文字列、更新の有無、使用するCSTRの番号
@FIRSTPROCESS(ARG, ARGS, ARG:1, ARG:2)
#FUNCTION
;空文字列の場合、/を1つ入れる
SIF CSTR:ARG:(ARG:2) == ""
	CSTR:ARG:(ARG:2) = /
;初回判定済みなら0を返す
SIF STRCOUNT(CSTR:ARG:(ARG:2), @"/%ARGS%/")
	RETURNF 0
;初回判定を更新しないチェックが無ければ更新
SIF !ARG:1
	CSTR:ARG:(ARG:2) = %CSTR:ARG:(ARG:2)%%ARGS%/
;初回なので1を返す
RETURNF 1

;-------------------------------------------------
;初回EVENT判定関数@FIRSTEVENT
;式中で使用する関数です。理論上無限にイベントを登録できます。
;EVENTと派生ごとに保存される初回判定用関数です。
;TFLAG:イベント番号（TFLAG:10）を自動で参照するので、現在発生しいるEVENTごとに番号が独立して保存されます。
;なお、他のイベントの初回判定を参照する場合は、ARG:3にイベント番号を入れることで一応可能です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTEVENT(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:イベント番号 # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"EVENT%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回助手EVENT判定関数@FIRSTEVENTASSI
;式中で使用する関数です。理論上無限にイベントを登録できます。
;助手EVENTと派生ごとに保存される初回判定用関数です。
;TFLAG:助手イベント番号（TFLAG:11）を自動で参照するので、現在発生しいる助手EVENTごとに番号が独立して保存されます。
;なお、他の助手イベントの初回判定を参照する場合は、ARG:3に助手イベント番号を入れることで一応可能です。
;ARGは助手イベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTEVENTASSI(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:助手イベント番号 # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"EVENTASSI%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回刻印判定関数@FIRSTMARK
;式中で使用する関数です。理論上無限にイベントを登録できます。
;刻印取得口上向けの初回判定用関数です。管理は通常のFIRSTTIME同様。使わないだろうけどあっても困らないので。
;ARGは口上番号（任意の設定）、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTMARK(ARG, ARG:1 = -2, ARG:2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF FIRSTPROCESS(ARG:1, @"MARK%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回脱衣判定関数@FIRSTDATUI
;式中で使用する関数です。理論上無限にイベントを登録できます。
;脱衣口上向けの初回判定用関数です。管理は通常のFIRSTTIME同様。使わないかもだけどあっても困らないので。
;ARGは口上番号（任意の設定）、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTDATUI(ARG, ARG:1 = -2, ARG:2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF FIRSTPROCESS(ARG:1, @"DATUI%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回ACTMESSAGE判定関数@FIRSTACTMESSAGE
;式中で使用する関数です。理論上無限にイベントを登録できます。
;ACTごとに保存される地の文口上初回判定用関数です。
;TFLAG:ACT（TFLAG:90）を自動で参照するので、現在実行されているACTごとに番号が独立して保存されます。
;つまり、「今の気分を聞く」内のFIRSTACTMESSAGE(0)と「性についての話をする」内のFIRSTACTMESSAGE(0)は別に管理されます。
;なお、他のACTの初回判定を参照する場合は、ARG:3にACT番号を入れることで一応可能です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTACTMESSAGE(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"ACTMESSAGE%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回ACT判定関数@FIRSTACT
;式中で使用する関数です。理論上無限にイベントを登録できます。
;ACTごとに保存される初回判定用関数です。
;TFLAG:ACT（TFLAG:90）を自動で参照するので、現在実行されているACTごとに番号が独立して保存されます。
;つまり、「今の気分を聞く」内のFIRSTACT(0)と「性についての話をする」内のFIRSTACT(0)は別に管理されます。
;なお、他のACTの初回判定を参照する場合は、ARG:3にACT番号を入れることで一応可能です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTACT(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"ACT%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回追加ACT判定関数@FIRSTACTEX
;式中で使用する関数です。理論上無限にイベントを登録できます。
;追加ACTごとに保存される初回判定用関数です。
;TFLAG:追加ACT（TFLAG:122）を自動で参照するので、現在実行されている追加ACTごとに番号が独立して保存されます。
;なお、他の追加ACTの初回判定を参照する場合は、ARG:3に追加ACT番号を入れることで一応可能です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTACTEX(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:追加ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"ACTEX%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回助手ACT判定関数@FIRSTACTASSI
;式中で使用する関数です。理論上無限にイベントを登録できます。
;助手ACTごとに保存される初回判定用関数です。
;TFLAG:助手ACT（TFLAG:122）を自動で参照するので、現在実行されている助手ACTごとに番号が独立して保存されます。
;なお、他の助手ACTの初回判定を参照する場合は、ARG:3に助手ACT番号を入れることで一応可能です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTACTASSI(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:助手ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"ACTASSI%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回薬品使用判定関数@FIRSTUSE
;式中で使用する関数です。理論上無限にイベントを登録できます。
;脱衣口上向けの初回判定用関数です。管理は通常のFIRSTTIME同様。使わないかもだけどあっても困らないので。
;ARGは口上番号（任意の設定）、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTUSE(ARG, ARG:1 = -2, ARG:2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF FIRSTPROCESS(ARG:1, @"USE%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回個別リアクション判定関数@FIRSTREACT
;式中で使用する関数です。理論上無限にイベントを登録できます。
;ACTごとに保存される初回判定用関数です。
;TFLAG:ACT（TFLAG:90）を自動で参照するので、現在実行されているACTごとに番号が独立して保存されます。
;つまり、「今の気分を聞く」内のFIRSTREACT(0)と「性についての話をする」内のFIRSTREACT(0)は別に管理されます。
;なお、他のACTの初回判定を参照する場合は、ARG:3にACT番号を入れることで一応可能です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTREACT(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"REACT%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回汎用リアクション判定関数@FIRSTCOM
;式中で使用する関数です。理論上無限にイベントを登録できます。
;COMごとに保存される初回判定用関数です。
;SELECTCOMを自動で参照するので、現在選択したCOMごとに番号が独立して保存されます。
;つまり、「消極的やる」内のFIRSTCOM(0)と「快感を受け入れる」内のFIRSTCOM(0)は別に管理されます。
;なお、他のCOMの初回判定を参照する場合は、ARG:3にCOM番号を入れることで一応可能です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTCOM(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? SELECTCOM # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"COM%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;初回統括汎用リアクション判定関数@FIRSTREACTALL
;式中で使用する関数です。理論上無限にイベントを登録できます。
;ACT分類ごとに保存される初回判定用関数です。
;TFLAG:ACT分類（TFLAG:80）を自動で参照するので、現在行われているACTの分類ごとに番号が独立して保存されます。
;つまり、「会話系アクション」内のFIRSTREACTALL(0)と「愛撫系アクション」内のFIRSTREACTALL(0)は別に管理されます。
;なお、他のACT分類の初回判定を参照する場合は、ARG:3にACT分類を入れることで一応可能です。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:0で管理します
;-------------------------------------------------
@FIRSTREACTALL(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:ACT分類 # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"REACTALL%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2)

;-------------------------------------------------
;調教内未読判定関数@ONCE
;式中で使用する関数です。理論上無限にイベントを登録できます。
;特に使用法に指定のない、イベントの初回判定用関数です。FIRSTTIMEと違い、調教前に初期化されます。
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）、ARG:2が真だと初回判定を更新しない（参照のみ）
;CSTR:1で管理します
;-------------------------------------------------
@ONCE(ARG, ARG:1 = -2, ARG:2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF FIRSTPROCESS(ARG:1, @"ONCE%TOSTR(ARG)%", ARG:2, 1)

;フラグリセット処理
@EVENTTRAIN
CVARSET CSTR, 3

;以下、FIRSTTIMEファミリーと同様のラインナップ

@ONCEEVENT(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:イベント番号 # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"EVENT%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)

@ONCEEVENTASSI(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:助手イベント番号 # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"EVENTASSI%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)

@ONCEMARK(ARG, ARG:1 = -2, ARG:2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF FIRSTPROCESS(ARG:1, @"MARK%TOSTR(ARG)%", ARG:2, 1)

@ONCEDATUI(ARG, ARG:1 = -2, ARG:2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF FIRSTPROCESS(ARG:1, @"DATUI%TOSTR(ARG)%", ARG:2, 1)

@ONCEACTMESSAGE(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"ACTMESSAGE%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)

@ONCEACT(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"ACT%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)

@ONCEACTEX(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:追加ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"ACTEX%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)

@ONCEACTASSI(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:助手ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"ACTASSI%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)

@ONCEUSE(ARG, ARG:1 = -2, ARG:2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF FIRSTPROCESS(ARG:1, @"USE%TOSTR(ARG)%", ARG:2, 1)

@ONCEREACT(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"REACT%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)

@ONCECOM(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? SELECTCOM # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"COM%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)

@ONCEREACTALL(ARG, ARG:1 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:3 = ARG:3 == -2 ? TFLAG:ACT分類 # ARG:3
RETURNF FIRSTPROCESS(ARG:1, @"REACTALL%TOSTR(ARG:3)%_%TOSTR(ARG)%", ARG:2, 1)


;-------------------------------------------------
;ランダムイベント整理関数@AUTORAND
;式中で使用する関数です。RAND処理でイベント種類ごとの番号を返しますが、全種見るまで同じ数字は返さない仕様です。
;特に使用法に指定のない、ランダムイベントの表示順整理関数です。ONCEと違い、調教前ではなく、全て表示したときに初期化されます。
;ARGはイベントの種類数（1以上100未満）、ARG:1はイベント番号、ARG:2はキャラ登録番号（省略するとTARGET）
;参照のみオプションはありません。CSTR:0で管理します…重いかな？
;-------------------------------------------------
@AUTORAND(ARG, ARG:1, ARG:2 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
SIF !RANGE(ARG, 1, 99)
	RETURNF 0

RETURNF AUTORANDPROCESS(ARG, ARG:2, @"AUTORAND%TOSTR(ARG:1)%")

;汎用AUTORAND処理
@AUTORANDPROCESS(ARG, ARG:1, ARGS)
#FUNCTION
#DIM DYNAMIC UNREAD, 1
#DIM LCOUNT, 1
#LOCALSIZE 100
VARSET LOCAL, -1
;未読の番号を数える
FOR LCOUNT, 0, ARG
	IF FIRSTPROCESS(ARG:1, @"%ARGS%_%TOSTR(LCOUNT)%", 1)
		LOCAL:UNREAD = LCOUNT
		UNREAD++
	ENDIF
NEXT
;未読がある場合、ランダムに選んで番号を返し、戻る
IF UNREAD
	UNREAD = LOCAL:(RAND:UNREAD)
	RETURNF FIRSTPROCESS(ARG:1, @"%ARGS%_%TOSTR(UNREAD)%")*UNREAD
;未読が無い場合、既読フラグをリセットして再帰する…ちょっと危ないけど大丈夫なはず
ELSE
	FOR LCOUNT, 0, ARG
		CSTR:(ARG:1):FIRSTTIME用 = %REPLACE(CSTR:(ARG:1):0, @"/%ARGS%_%TOSTR(LCOUNT)%/", "/")%
	NEXT
	RETURNF AUTORANDPROCESS(ARG, ARG:1, ARGS)
ENDIF

;以下、FIRSTTIMEファミリーと同様のラインナップ

@RANDEVENT(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? TFLAG:イベント番号 # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDEVENT%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")

@RANDEVENTASSI(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? TFLAG:助手イベント番号 # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDEVENTASSI%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")

@RANDMARK(ARG, ARG:1, ARG:2 = -2, ARG:2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDMARK%TOSTR(ARG:1)%")

@RANDDATUI(ARG, ARG:1, ARG:2 = -2, ARG:2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDDATUI%TOSTR(ARG:1)%")

@RANDACTMESSAGE(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDACTMESSAGE%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")

@RANDACT(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDACT%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")

@RANDACTEX(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? TFLAG:追加ACT # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDACTEX%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")

@RANDACTASSI(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? TFLAG:助手ACT # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDACTASSI%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")

@RANDUSE(ARG, ARG:1, ARG:2 = -2, ARG:2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDUSE%TOSTR(ARG:1)%")

@RANDREACT(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? TFLAG:ACT # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDREACT%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")

@RANDCOM(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? SELECTCOM # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDCOM%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")

@RANDREACTALL(ARG, ARG:1, ARG:2 = -2, ARG:2, ARG:3 = -2)
#FUNCTION
ARG:2 = ARG:2 == -2 ? TARGET # ARG:2
ARG:3 = ARG:3 == -2 ? TFLAG:ACT分類 # ARG:3
RETURNF AUTORANDPROCESS(ARG, ARG:2, @"RANDREACTALL%TOSTR(ARG:3)%_%TOSTR(ARG:1)%")


;-------------------------------------------------
;順序イベント整理関数@AUTOORDER
;式中で使用する関数です。呼ばれるたびにそのイベントが何度目に呼ばれたかを返します。初期化はされません。
;特に使用法に指定のない、段階式イベントの表示順整理関数です。0〜100まで呼ばれるごとに更新します
;ARGはイベント番号、ARG:1はキャラ登録番号（省略するとTARGET）
;こちらも面倒なので、参照のみオプションはありません。そういうのが必要な処理はFIRSTTIMEで行ってください。
;CSTR:0で管理します…重いかな？
;-------------------------------------------------
@AUTOORDER(ARG, ARG:1 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF AUTOORDERPROCESS(ARG:1, @"AUTOORDER%TOSTR(ARG)%")

;汎用AUTOORDER処理
@AUTOORDERPROCESS(ARG, ARGS)
#FUNCTION
#DIM LCOUNT, 1
#LOCALSIZE 100
VARSET LOCAL, -1
;0〜99の未読判定をし、最初に引っかかった数字を返す
FOR LCOUNT, 0, 100
	SIF FIRSTPROCESS(ARG, @"%ARGS%_%TOSTR(LCOUNT)%")
		RETURNF LCOUNT
NEXT
;限界は100
RETURNF 100

;以下、FIRSTTIMEファミリーと同様のラインナップ

@ORDEREVENT(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? TFLAG:イベント番号 # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDEREVENT%TOSTR(ARG:2)%_%TOSTR(ARG)%")

@ORDEREVENTASSI(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? TFLAG:助手イベント番号 # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDEREVENTASSI%TOSTR(ARG:2)%_%TOSTR(ARG)%")

@ORDERMARK(ARG, ARG:1 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERMARK%TOSTR(ARG)%")

@ORDERDATUI(ARG, ARG:1 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERDATUI%TOSTR(ARG)%")

@ORDERACTMESSAGE(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? TFLAG:ACT # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERACTMESSAGE%TOSTR(ARG:2)%_%TOSTR(ARG)%")

@ORDERACT(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? TFLAG:ACT # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERACT%TOSTR(ARG:2)%_%TOSTR(ARG)%")

@ORDERACTEX(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? TFLAG:追加ACT # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERACTEX%TOSTR(ARG:2)%_%TOSTR(ARG)%")

@ORDERACTASSI(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? TFLAG:助手ACT # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERACTASSI%TOSTR(ARG:2)%_%TOSTR(ARG)%")

@ORDERUSE(ARG, ARG:1 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERUSE%TOSTR(ARG)%")

@ORDERREACT(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? TFLAG:ACT # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERREACT%TOSTR(ARG:2)%_%TOSTR(ARG)%")

@ORDERCOM(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? SELECTCOM # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERCOM%TOSTR(ARG:2)%_%TOSTR(ARG)%")

@ORDERREACTALL(ARG, ARG:1 = -2, ARG:2 = -2)
#FUNCTION
ARG:1 = ARG:1 == -2 ? TARGET # ARG:1
ARG:2 = ARG:2 == -2 ? TFLAG:ACT分類 # ARG:2
RETURNF AUTOORDERPROCESS(ARG:1, @"ORDERREACTALL%TOSTR(ARG:2)%_%TOSTR(ARG)%")

;-------------------------------------------------
;関数名:VOIDLINE_IF
;概　要:条件付き空行
;引　数:ARG:0…正なら空行表示
;戻り値:RESULTを保存する
;備　考:口上表示したときの空行追加用
;-------------------------------------------------
@VOIDLINE_IF(ARG)
SIF ARG
	PRINTL 
RETURN RESULT

;-------------------------------------------------
;関数名:LINE_IF
;概　要:条件付きDRAWLINE
;引　数:ARG:0…正ならDRAWLINE
;戻り値:RESULTを保存する
;備　考:口上表示したときの罫線追加用
;-------------------------------------------------
@LINE_IF(ARG)
SIF ARG
	DRAWLINE
RETURN RESULT

;-------------------------------------------------
;真値集計関数@TRUECHECK
;	引数0〜19：集計対象
;引数のうち真になるものがいくつあるかを数えます
;-------------------------------------------------
@TRUECHECK(ARG, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20, ARG:21, ARG:22, ARG:23, ARG:24, ARG:25, ARG:26, ARG:27, ARG:28, ARG:29, ARG:30, ARG:31, ARG:32, ARG:33, ARG:34, ARG:35, ARG:36, ARG:37, ARG:38, ARG:39, ARG:40, ARG:41, ARG:42, ARG:43, ARG:44, ARG:45, ARG:46, ARG:47, ARG:48, ARG:49, ARG:50, ARG:51, ARG:52, ARG:53, ARG:54, ARG:55, ARG:56, ARG:57, ARG:58, ARG:59, ARG:60, ARG:61, ARG:62, ARG:63, ARG:64, ARG:65, ARG:66, ARG:67, ARG:68, ARG:69, ARG:70, ARG:71, ARG:72, ARG:73, ARG:74, ARG:75, ARG:76, ARG:77, ARG:78, ARG:79, ARG:80, ARG:81, ARG:82, ARG:83, ARG:84, ARG:85, ARG:86, ARG:87, ARG:88, ARG:89, ARG:90, ARG:91, ARG:92, ARG:93, ARG:94, ARG:95, ARG:96, ARG:97, ARG:98, ARG:99)
#FUNCTION
#LOCALSIZE 1
#DIM LCOUNT, 1
LOCAL = 0
FOR LCOUNT, 0, 100
	SIF ARG:LCOUNT > 0
		LOCAL ++
NEXT
RETURNF LOCAL

;-------------------------------------------------
;複数ビットセット関数@SETBITS
;	引数0：セットする対象
;	引数1〜100：セットに用いられる数値
;通常関数です。引数0の値に与えられた引数番目のビットを立てます
;-------------------------------------------------
@SETBITS(ARG, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#LOCALSIZE 2
LOCAL = 0
FOR LOCAL:1, 1, 100
	SIF ARG:(LOCAL:1) < 0 || ARG:(LOCAL:1) > 63
		RETURN RESULT
	SETBIT ARG, ARG:(LOCAL:1)
NEXT
RETURN RESULT

;-------------------------------------------------
;関数名:COUNTBIT
;概　要:BIT和取得関数
;引　数:ARG:0…対象の変数
;　　　:ARG:1…BIT番号始点
;　　　:ARG:2…BIT番号終点
;戻り値:ARG:1〜ARG:2番目のビットの和
;備　考:式中関数。引数1〜2を省略すると全BITの和になる
;-------------------------------------------------
@COUNTBIT(ARG, ARG:1, ARG:2 = 63)
#FUNCTION
#LOCALSIZE 2
LOCAL:1 = 0
ARG >>= ARG:1
FOR LOCAL, 0, ARG:1-ARG:2+1
	LOCAL:1 += ARG & 1
	ARG >>= 1
NEXT
RETURNF LOCAL:1

;-------------------------------------------------
;ORビットチェック関数@GETBITOR
;	引数0：チェックされる数値・変数
;	引数1〜100：チェックするビット
;式中で使用する関数です。引数0の値で与えられた引数1〜100番目のビットを見ます。いずれかが立っていれば1を返します
;引数0はチェックする対象、チェックされる数値は100まで引き受け可能
;チェック数値がすべて省略されるか不適切だと0が返ります
;-------------------------------------------------
@GETBITOR(ARG, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#FUNCTION
#DIM LCOUNT, 1
FOR LCOUNT, 1, 100
	SIF ARG:LCOUNT < 0 || ARG:LCOUNT > 63
		RETURNF 0
	SIF GETBIT(ARG, ARG:LCOUNT)
		RETURNF 1
NEXT
RETURNF 0

;-------------------------------------------------
;配列ビットチェック関数@GETBITAR
;	引数0：チェックするビット
;	引数1〜100：チェックされる数値・変数
;式中で使用する関数です。引数0の値番目のビットを引数1〜100番目に対して見ます。いずれかで立っていれば1を返します
;GETBITOR等と比べて引数配置が逆になっています。また、便宜上配列と銘打ってますが配列をまとめて扱うことはできません
;チェック数値がすべて省略されるか不適切だと0が返ります
;-------------------------------------------------
@GETBITAR(ARG = -1 , ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#FUNCTION
#DIM LCOUNT, 1
SIF ARG < 0 || ARG > 63
	RETURNF 0
FOR LCOUNT, 1, 100
	SIF ARG:LCOUNT < 0
		RETURNF 0
	SIF GETBIT(ARG:LCOUNT, ARG)
		RETURNF 1
NEXT
RETURNF 0

;-------------------------------------------------
;ANDビットチェック関数@GETBITAND
;	引数0：チェックされる数値・変数
;	引数1〜100：チェックするビット
;式中で使用する関数です。引数0の値で与えられた引数1〜100番目のビットを見ます。すべて立っていれば1を返します
;引数0はチェックする対象、チェックされる数値は100まで引き受け可能
;チェック数値がすべて省略されるか不適切だと1が返ります
;-------------------------------------------------
@GETBITAND(ARG, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#FUNCTION
#DIM LCOUNT, 1
FOR LCOUNT, 1, 100
	SIF ARG:LCOUNT < 0 || ARG:LCOUNT > 63
		RETURNF 1
	SIF !GETBIT(ARG, ARG:LCOUNT)
		RETURNF 0
NEXT
RETURNF 1

;-------------------------------------------------
;除外ビットチェック関数@GETBITEX
;	引数0：チェックされる数値・変数
;	引数1〜100：チェックするビット
;式中で使用する関数です。引数0の値で与えられた引数1〜100番目のビットを見ます。それらのビット以外に何か立っていれば真になります
;それらのビットが立っているかどうか自体は見ないので、見たい場合はGETBITORを併用してください
;引数0はチェックする対象、チェックされる数値は100まで引き受け可能
;チェック数値がすべて省略されるか不適切だと1が返ります
;-------------------------------------------------
@GETBITEX(ARG, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#FUNCTION
#DIM LCOUNT, 1
FOR LCOUNT, 1, 100
	SIF ARG:LCOUNT < 0 || ARG:LCOUNT > 63
		RETURNF ARG
	CLEARBIT ARG, ARG:LCOUNT
NEXT
RETURNF ARG

;-------------------------------------------------
;関数名:_PARSE_INT
;概　要:数値解析サポート関数
;引　数:ARGS…解析する文字列,
;　　　 ARG …基数(2〜16)。省略した場合は10
;戻り値:解析結果。解析できない場合は-1
;備　考:式中関数
;ARGSを、ARG進数と見なして解析する関数
;この関数は0〜9とA〜Fおよびa〜fしか見ないので、
;頭にマイナス符号があるとエラーになります
;マイナスの処理は他所でやってください
;一応、内部関数扱いなので他所では使用しないように
;…する必要があるのかどうか知らないけど
;-------------------------------------------------
@_PARSE_INT(ARGS, ARG = 10)
#FUNCTION
#LOCALSIZE 10
#LOCALSSIZE 10
;ARGSが省略された場合(または空文字列の場合)、エラーとする
SIF ARGS == ""
	RETURNF -1

;ARGが2未満または16より大きい場合、エラーとする
SIF ARG < 2 || 16 < ARG 
	RETURNF -1

;解析結果
LOCAL:0 = 0

;SUBSTRINGの開始位置
LOCAL:1 = 0

;文字数分ループする
WHILE LOCAL:1 < STRLENS(ARGS)
	;ARGSから1文字抜き出してLOCALSに格納する
	;開始位置または終了位置で文字を切ることができない場合(全角文字の途中を指している場合)、1つ後ろを指定されたと判断する
	LOCALS = %SUBSTRING(ARGS, LOCAL:1, 1)%
	
	;LOCALSの長さ(SHIFT-JISでのバイト数)を取得し、SUBSTRINGの開始位置を移動
	;1バイト文字(半角)なら+1、2バイト文字(全角)なら+2
	LOCAL:1 += STRLENS(LOCALS)
	
	;文字毎に分岐
	SELECTCASE LOCALS
		CASE "0"
			;これまでの解析結果を基数倍し、解析した文字に相当する値を加算する
			LOCAL:0 = LOCAL:0 * ARG + 0
		CASE "1"
			LOCAL:0 = LOCAL:0 * ARG + 1
		CASE "2"
			;基数が3未満で2が検出されたらエラー
			SIF ARG < 3
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 2
		CASE "3"
			SIF ARG < 4
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 3
		CASE "4"
			SIF ARG < 5
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 4
		CASE "5"
			SIF ARG < 6
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 5
		CASE "6"
			SIF ARG < 7
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 6
		CASE "7"
			SIF ARG < 8
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 7
		CASE "8"
			SIF ARG < 9
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 8
		CASE "9"
			;基数が10未満で9が検出されたらエラー
			SIF ARG < 10
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 9
		;10
		CASE "A", "a"
			;基数が11未満でAまたはaが検出されたらエラー
			SIF ARG < 11
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 10
		;11
		CASE "B", "b"
			SIF ARG < 12
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 11
		;12
		CASE "C", "c"
			SIF ARG < 13
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 12
		;13
		CASE "D", "d"
			SIF ARG < 14
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 13
		;14
		CASE "E", "e"
			SIF ARG < 15
				RETURNF -1
			LOCAL:0 = LOCAL:0 * ARG + 14
		;15
		CASE "F", "f"
			;基数が16未満でFまたはfが検出されたらエラー
			SIF ARG < 16
				RETURNF -1
			;これまでの解析結果を基数倍し、解析した文字に相当する値を加算する
			LOCAL:0 = LOCAL:0 * ARG + 15
		;未定義の文字
		CASEELSE
			;未定義の文字が検出されたらエラー
			RETURNF -1
	ENDSELECT
WEND

;解析結果を返す
RETURNF LOCAL:0

;-------------------------------------------------
;口上色指定文字列表示関数@PRINT_KOJO_COLOR〜系
;	引数0：キャラ番号
;	引数1：文字列
;
;指定したキャラ番号の文字色で文字列を表示します
;当該キャラの専用口上が存在しない場合はデフォルトの薄灰色で表示
;改行する「PRINT_KOJO_COLORL」改行待ちする「PRINT_KOJO_COLORW」のバリエーションあり
;例えば…
;CALL PRINT_KOJO_COLORW(ASSI, "この文字列はASSIの設定色で表示されて改行待ちをします。")
;ぱにめーしょんに入れたいがバリアント互換がないのでここで。
;-------------------------------------------------
@PRINT_KOJO_COLOR(ARG, ARGS, ARG:1)
IF ARG == TARGET
	CALL KOJO_COLOR(TARGET)
ELSEIF ARG == MASTER
	CALL KOJO_COLOR(MASTER)
ELSEIF ARG == ASSI
	CALL KOJO_COLOR(ASSI)
ENDIF
PRINTFORM %ARGS%
IF ARG:1 == 1
	PRINTFORML
ELSEIF ARG:1 == 2
	PRINTFORMW
ENDIF
CALL KOJO_COLOR(TARGET)
RETURN RESULT

@PRINT_KOJO_COLORL(ARG, ARGS)
CALL PRINT_KOJO_COLOR(ARG,ARGS, 1)
RETURN RESULT

@PRINT_KOJO_COLORW(ARG, ARGS)
CALL PRINT_KOJO_COLOR(ARG,ARGS, 2)
RETURN RESULT

;_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/#
;
;	Module		:AUTO_SPLIT.ERB
;	Facility	:引数として渡されたARGSから、特定の文字列ARGS:1で区切った場合のARG番目の文字列を返す関数@AUTO_SPLIT
;
;	Licence		:ライセンスフリー。
;
;	Modification Data:
;
;	Edit	Date			Author					Reason
;	001		2011/09/25		Ｎ鳥					新規作成
;_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/#
;
;@AUTO_SPLIT
;ARGS   操作する文字列
;ARGS:1 ARGSを区切る文字列
;ARG 　 ARGSを区切った後で、操作する箇所。ARGS:2が指定されている場合、発見したARGS:2の場所+ARG番目の文字列を返す。
;ARGS:2 検索する文字列
;================================================
@AUTO_SPLIT(ARGS , ARGS:1 , ARG = 0 , ARGS:2 = "")
#FUNCTIONS
#LOCALSSIZE 200
#LOCALSIZE 1
VARSET LOCALS
SPLIT ARGS , ARGS:1 , LOCALS
IF ARGS:2 != ""
	LOCAL = FINDELEMENT(LOCALS , ARGS:2 , , , 1)
	IF LOCAL != -1
		SIF ARG + LOCAL < 0
			PRINTFORML エラー：関数@AUTO_SPLITにて{LOCAL}番目の文字列に%ARGS:2%を発見しましたが、第三引数{ARG}の指定が不正です。
		RETURNF LOCALS:(LOCAL + ARG)
	ELSE
		RETURNF
	ENDIF
ELSE
	SIF ARG < 0
		PRINTFORML エラー：関数@AUTO_SPLITの第三引数として{ARG}が渡されました
	RETURNF LOCALS:ARG
ENDIF


